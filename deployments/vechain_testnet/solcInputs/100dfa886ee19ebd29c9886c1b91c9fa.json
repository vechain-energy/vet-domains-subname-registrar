{
  "language": "Solidity",
  "sources": {
    "contracts/ethregistrar/StringUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nlibrary StringUtils {\n    /**\n     * @dev Returns the length of a given string\n     *\n     * @param s The string to measure the length of\n     * @return The length of the input string\n     */\n    function strlen(string memory s) internal pure returns (uint256) {\n        uint256 len;\n        uint256 i = 0;\n        uint256 bytelength = bytes(s).length;\n        for (len = 0; i < bytelength; len++) {\n            bytes1 b = bytes(s)[i];\n            if (b < 0x80) {\n                i += 1;\n            } else if (b < 0xE0) {\n                i += 2;\n            } else if (b < 0xF0) {\n                i += 3;\n            } else if (b < 0xF8) {\n                i += 4;\n            } else if (b < 0xFC) {\n                i += 5;\n            } else {\n                i += 6;\n            }\n        }\n        return len;\n    }\n\n    /**\n     * @dev Escapes special characters in a given string\n     *\n     * @param str The string to escape\n     * @return The escaped string\n     */\n    function escape(string memory str) internal pure returns (string memory) {\n        bytes memory strBytes = bytes(str);\n        uint extraChars = 0;\n\n        // count extra space needed for escaping\n        for (uint i = 0; i < strBytes.length; i++) {\n            if (_needsEscaping(strBytes[i])) {\n                extraChars++;\n            }\n        }\n\n        // allocate buffer with the exact size needed\n        bytes memory buffer = new bytes(strBytes.length + extraChars);\n        uint index = 0;\n\n        // escape characters\n        for (uint i = 0; i < strBytes.length; i++) {\n            if (_needsEscaping(strBytes[i])) {\n                buffer[index++] = \"\\\\\";\n                buffer[index++] = _getEscapedChar(strBytes[i]);\n            } else {\n                buffer[index++] = strBytes[i];\n            }\n        }\n\n        return string(buffer);\n    }\n\n    // determine if a character needs escaping\n    function _needsEscaping(bytes1 char) private pure returns (bool) {\n        return\n            char == '\"' ||\n            char == \"/\" ||\n            char == \"\\\\\" ||\n            char == \"\\n\" ||\n            char == \"\\r\" ||\n            char == \"\\t\";\n    }\n\n    // get the escaped character\n    function _getEscapedChar(bytes1 char) private pure returns (bytes1) {\n        if (char == \"\\n\") return \"n\";\n        if (char == \"\\r\") return \"r\";\n        if (char == \"\\t\") return \"t\";\n        return char;\n    }\n}"
    },
    "contracts/interfaces/ENS.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n \ninterface ENS {\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n \n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n \n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n \n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n \n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n \n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n \n    function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n \n    function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external returns (bytes32);\n \n    function setResolver(bytes32 node, address resolver) external;\n \n    function setOwner(bytes32 node, address owner) external;\n \n    function setTTL(bytes32 node, uint64 ttl) external;\n \n    function setApprovalForAll(address operator, bool approved) external;\n \n    function owner(bytes32 node) external view returns (address);\n \n    function resolver(bytes32 node) external view returns (address);\n \n    function ttl(bytes32 node) external view returns (uint64);\n \n    function recordExists(bytes32 node) external view returns (bool);\n \n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n}"
    },
    "contracts/interfaces/PublicResolver.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n \ninterface PublicResolver {\n \n    // Logged when the address associated with a name is changed.\n    event AddrChanged(bytes32 indexed node, address a);\n \n    // Logged when a text record is changed.\n    event TextChanged(bytes32 indexed node, string indexed key, string value);\n \n    // Logged when the name associated with an address is changed in reverse resolution.\n    event NameChanged(bytes32 indexed node, string name);\n \n    // Logged when an ABI is changed.\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\n \n    // Logged when a pubkey is changed.\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\n \n    // Logged when a contenthash is changed.\n    event ContenthashChanged(bytes32 indexed node, bytes contenthash);\n \n    // Function to get the address associated with a node.\n    function addr(bytes32 node) external view returns (address);\n \n    // Function to set the address associated with a node.\n    function setAddr(bytes32 node, address a) external;\n \n    // Function to get a text record.\n    function text(bytes32 node, string calldata key) external view returns (string memory);\n \n    // Function to set a text record.\n    function setText(bytes32 node, string calldata key, string calldata value) external;\n \n    // Function to get the name associated with a node in reverse resolution.\n    function name(bytes32 node) external view returns (string memory);\n \n    // Function to set the name associated with a node in reverse resolution.\n    function setName(bytes32 node, string calldata name) external;\n \n    // Function to get an ABI.\n    function ABI(bytes32 node, uint256 contentType) external view returns (uint256, bytes memory);\n \n    // Function to set an ABI.\n    function setABI(bytes32 node, uint256 contentType, bytes calldata data) external;\n \n    // Function to get a pubkey.\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);\n \n    // Function to set a pubkey.\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n \n    // Function to get a contenthash.\n    function contenthash(bytes32 node) external view returns (bytes memory);\n \n    // Function to set a contenthash.\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n \n    // Function to check if a contract implements an interface.\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool);\n}"
    },
    "contracts/SubdomainClaimer.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\n// VNS Interface: https://docs.vet.domains/Developers/Contracts/Registry/\nimport \"./interfaces/ENS.sol\";\n\n// Resolver Interface: https://docs.vet.domains/Developers/Contracts/Resolver/\nimport \"./interfaces/PublicResolver.sol\";\n\nimport {StringUtils} from \"./ethregistrar/StringUtils.sol\";\nimport \"./utils/Namehash.sol\";\n\n/**\n * A registrar that allocates subdomains to the first person to claim them.\n */\ncontract SubdomainClaimer {\n    using StringUtils for *;\n\n    ENS public immutable ens;\n    bytes32 public node;\n    string public domainName;\n\n    /**\n     * Constructor.\n     * @param ensAddr The address of the ENS registry.\n     * @param _domainName The subdomain to manage\n     */\n    constructor(ENS ensAddr, string memory _domainName) {\n        ens = ensAddr;\n        domainName = _domainName;\n        node = Namehash.namehash(domainName);\n    }\n\n    /**\n     * Register a name, or change the owner of an existing registration.\n     * @param name The name of the subdomain (foo if you want foo.example.vet)\n     * @param resolver The resolver to set on the subdomain.\n     */\n    function claim(string memory name, PublicResolver resolver) public {\n        bytes32 label = keccak256(bytes(name));\n        bytes32 subnode = keccak256(abi.encodePacked(node, label));\n\n        require(!ens.recordExists(subnode), \"Subdomain already claimed.\");\n\n        // Create subdomain by assigning ownership to this contract for management purpose\n        ens.setSubnodeOwner(node, label, address(this));\n\n        // Set the subdomain's resolver\n        ens.setResolver(subnode, address(resolver));\n\n        // Set the address record on the resolver\n        resolver.setAddr(subnode, msg.sender);\n\n        // Set ownership for new subdomain\n        ens.setSubnodeOwner(node, label, msg.sender);\n    }\n}\n"
    },
    "contracts/utils/Namehash.sol": {
      "content": "pragma solidity 0.8.19;\n\nlibrary Strings {\n    struct slice {\n        uint _len;\n        uint _ptr;\n    }\n    \n    /*\n     * @dev Returns a slice containing the entire string.\n     * @param self The string to make a slice from.\n     * @return A newly allocated slice containing the entire string.\n     */\n    function toSlice(string memory self) internal pure returns (slice memory) {\n        uint ptr;\n        assembly {\n            ptr := add(self, 0x20)\n        }\n        return slice(bytes(self).length, ptr);\n    }\n\n    /*\n     * @dev Returns the keccak-256 hash of the slice.\n     * @param self The slice to hash.\n     * @return The hash of the slice.\n     */\n    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n        assembly {\n            ret := keccak256(mload(add(self, 32)), mload(self))\n        }\n    }\n\n    /*\n     * @dev Returns true if the slice is empty (has a length of 0).\n     * @param self The slice to operate on.\n     * @return True if the slice is empty, False otherwise.\n     */\n    function empty(slice memory self) internal pure returns (bool) {\n        return self._len == 0;\n    }\n    \n    // Returns the memory address of the first byte after the last occurrence of\n    // `needle` in `self`, or the address of `self` if not found.\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n        uint ptr;\n\n        if (needlelen <= selflen) {\n            if (needlelen <= 32) {\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n                bytes32 needledata;\n                assembly { needledata := and(mload(needleptr), mask) }\n\n                ptr = selfptr + selflen - needlelen;\n                bytes32 ptrdata;\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n                while (ptrdata != needledata) {\n                    if (ptr <= selfptr)\n                        return selfptr;\n                    ptr--;\n                    assembly { ptrdata := and(mload(ptr), mask) }\n                }\n                return ptr + needlelen;\n            } else {\n                // For long needles, use hashing\n                bytes32 hash;\n                assembly { hash := keccak256(needleptr, needlelen) }\n                ptr = selfptr + (selflen - needlelen);\n                while (ptr >= selfptr) {\n                    bytes32 testHash;\n                    assembly { testHash := keccak256(ptr, needlelen) }\n                    if (hash == testHash)\n                        return ptr + needlelen;\n                    ptr -= 1;\n                }\n            }\n        }\n        return selfptr;\n    }\n    \n    /*\n     * @dev Splits the slice, setting `self` to everything before the last\n     *      occurrence of `needle`, and `token` to everything after it. If\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n     *      and `token` is set to the entirety of `self`.\n     * @param self The slice to split.\n     * @param needle The text to search for in `self`.\n     * @param token An output parameter to which the first token is written.\n     * @return `token`.\n     */\n    function rsplit(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n        token._ptr = ptr;\n        token._len = self._len - (ptr - self._ptr);\n        if (ptr == self._ptr) {\n            // Not found\n            self._len = 0;\n        } else {\n            self._len -= token._len + needle._len;\n        }\n        return token;\n    }\n}\n\nlibrary Namehash {\n    using Strings for *;\n    \n    function namehash(string memory name) pure internal returns(bytes32 hash) {\n        hash = bytes32(0);\n        Strings.slice memory nameslice = name.toSlice();\n        Strings.slice memory delim = \".\".toSlice();\n        Strings.slice memory token;\n        for(nameslice.rsplit(delim, token); !token.empty(); nameslice.rsplit(delim, token)) {\n            hash = keccak256(abi.encodePacked(hash, token.keccak()));\n        }\n        return hash;\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}